// ===== CONFIGURA√á√ÉO =====
const REPO = "Hmdgt/Tol_v2";
const CAMINHO_NOTIFICACOES = "resultados/notificacoes_ativas.json";
const CAMINHO_HISTORICO = "resultados/notificacoes_historico.json";
const GITHUB_RAW = `https://raw.githubusercontent.com/${REPO}/main/${CAMINHO_NOTIFICACOES}`;
const GITHUB_API = `https://api.github.com/repos/${REPO}/contents/${CAMINHO_NOTIFICACOES}`;
const GITHUB_HISTORICO_API = `https://api.github.com/repos/${REPO}/contents/${CAMINHO_HISTORICO}`;

// Cache duration (5 minutos)
const CACHE_DURATION = 5 * 60 * 1000;

// ===== FUN√á√ïES PRINCIPAIS =====

// 1. Carregar notifica√ß√µes (com cache e localStorage)
async function carregarNotificacoes(forceRefresh = false) {
    try {
        // Se n√£o for√ßar refresh, tentar usar localStorage primeiro
        if (!forceRefresh) {
            const cached = localStorage.getItem('notificacoes_cache');
            const timestamp = localStorage.getItem('notificacoes_timestamp');
            
            if (cached && timestamp) {
                const age = Date.now() - parseInt(timestamp);
                if (age < CACHE_DURATION) {
                    console.log('üì¶ Usando cache do localStorage');
                    return JSON.parse(cached);
                }
            }
        }
        
        // Buscar do GitHub
        console.log('üåê Buscando do GitHub...');
        const response = await fetch(GITHUB_RAW + `?t=${Date.now()}`);
        if (!response.ok) throw new Error('Erro ao carregar');
        
        const data = await response.json();
        
        // Guardar no localStorage
        localStorage.setItem('notificacoes_cache', JSON.stringify(data));
        localStorage.setItem('notificacoes_timestamp', Date.now());
        
        return data;
    } catch (error) {
        console.error('Erro:', error);
        
        // Se falhar, tentar usar cache mesmo expirado
        const cached = localStorage.getItem('notificacoes_cache');
        return cached ? JSON.parse(cached) : [];
    }
}

// 2. Atualizar badge no index.html
async function atualizarBadge() {
    const notificacoes = await carregarNotificacoes();
    const naoLidas = notificacoes.filter(n => !n.lido).length;
    
    // Guardar contagem no localStorage
    localStorage.setItem('notificacoes_naoLidas', naoLidas);
    
    const badge = document.getElementById('notificationBadge');
    if (badge) {
        if (naoLidas > 0) {
            badge.style.display = 'flex';
            badge.textContent = naoLidas > 99 ? '99+' : naoLidas;
            console.log(`üîî Badge atualizado: ${naoLidas} notifica√ß√µes`);
        } else {
            badge.style.display = 'none';
            console.log('üîî Badge removido');
        }
    }
    
    return notificacoes;
}

// 3. For√ßar atualiza√ß√£o do badge (chamar ap√≥s marcar como lida)
async function forcarAtualizacaoBadge() {
    // Limpar cache
    localStorage.removeItem('notificacoes_cache');
    localStorage.removeItem('notificacoes_timestamp');
    
    // Buscar novo do GitHub
    await atualizarBadge();
}

// 4. Marcar notifica√ß√£o como lida (via API GitHub)
async function marcarComoLida(idNotificacao) {
    const token = localStorage.getItem("github_token");
    if (!token) {
        alert("Token n√£o configurado. Vai √†s Configura√ß√µes.");
        return false;
    }
    
    try {
        // Mostrar feedback visual
        mostrarToast('A marcar como lida...');
        
        // ===== 1. ATUALIZAR NOTIFICA√á√ïES ATIVAS =====
        const res = await fetch(GITHUB_API, {
            headers: { 'Authorization': `Bearer ${token}` }
        });
        
        if (!res.ok) {
            console.error('Erro ao buscar ficheiro:', await res.text());
            return false;
        }
        
        const ficheiro = await res.json();
        let notificacoes = JSON.parse(atob(ficheiro.content));
        
        const notificacaoLida = notificacoes.find(n => n.id === idNotificacao);
        const novasAtivas = notificacoes.filter(n => n.id !== idNotificacao);
        
        if (!notificacaoLida) {
            console.log('Notifica√ß√£o n√£o encontrada');
            return false;
        }
        
        // Marcar como lida e adicionar timestamp
        notificacaoLida.lido = true;
        notificacaoLida.data_leitura = new Date().toISOString();
        
        // Atualizar notifica√ß√µes ativas (remover a lida)
        const updateRes = await fetch(GITHUB_API, {
            method: 'PUT',
            headers: {
                'Authorization': `Bearer ${token}`,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                message: `Notifica√ß√£o ${idNotificacao} marcada como lida`,
                content: btoa(JSON.stringify(novasAtivas, null, 2)),
                sha: ficheiro.sha
            })
        });
        
        if (!updateRes.ok) {
            console.error('Erro ao atualizar ativas:', await updateRes.text());
            return false;
        }
        
        // ===== 2. ADICIONAR AO HIST√ìRICO =====
        let historico = [];
        let shaHist = null;
        
        try {
            const resHist = await fetch(GITHUB_HISTORICO_API, {
                headers: { 'Authorization': `Bearer ${token}` }
            });
            
            if (resHist.ok) {
                const ficheiroHist = await resHist.json();
                historico = JSON.parse(atob(ficheiroHist.content));
                shaHist = ficheiroHist.sha;
            }
        } catch (e) {
            console.log('Hist√≥rico ainda n√£o existe, vai ser criado');
        }
        
        // Adicionar notifica√ß√£o lida ao hist√≥rico
        historico.push(notificacaoLida);
        
        // Atualizar hist√≥rico
        await fetch(GITHUB_HISTORICO_API, {
            method: 'PUT',
            headers: {
                'Authorization': `Bearer ${token}`,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                message: `Notifica√ß√£o ${idNotificacao} adicionada ao hist√≥rico`,
                content: btoa(JSON.stringify(historico, null, 2)),
                sha: shaHist
            })
        });
        
        console.log('‚úÖ Notifica√ß√£o movida para o hist√≥rico');
        
        // LIMPAR CACHE E FOR√áAR ATUALIZA√á√ÉO DO BADGE
        localStorage.removeItem('notificacoes_cache');
        localStorage.removeItem('notificacoes_timestamp');
        
        // Atualizar badge imediatamente
        await forcarAtualizacaoBadge();
        
        mostrarToast('‚úÖ Notifica√ß√£o marcada como lida', 'success');
        
        return true;
        
    } catch (error) {
        console.error('Erro ao marcar como lida:', error);
        mostrarToast('‚ùå Erro ao marcar como lida', 'error');
        return false;
    }
}

// 5. Mostrar toast (feedback visual)
function mostrarToast(mensagem, tipo = 'info') {
    const toast = document.createElement('div');
    toast.style.cssText = `
        position: fixed;
        bottom: 100px;
        left: 20px;
        right: 20px;
        background: ${tipo === 'success' ? '#4CAF50' : tipo === 'error' ? '#f44336' : '#333'};
        color: white;
        padding: 12px;
        border-radius: 8px;
        text-align: center;
        font-size: 14px;
        z-index: 2000;
        animation: fadeInOut 2s ease;
    `;
    toast.textContent = mensagem;
    document.body.appendChild(toast);
    
    setTimeout(() => toast.remove(), 2000);
}

// 6. Renderizar lista de notifica√ß√µes (S√ì N√ÉO LIDAS)
async function renderizarNotificacoes() {
    const listaElement = document.getElementById('notificationsList');
    if (!listaElement) return;
    
    const notificacoes = await carregarNotificacoes(true); // For√ßar refresh
    
    // Filtrar apenas n√£o lidas
    const naoLidas = notificacoes.filter(n => !n.lido);
    
    if (naoLidas.length === 0) {
        listaElement.innerHTML = '<div class="no-notifications">‚ú® Nenhuma notifica√ß√£o</div>';
        return;
    }
    
    let html = '';
    for (const notif of naoLidas) {
        html += `
            <div class="notification-card" data-id="${notif.id}" data-lido="${notif.lido}">
                <div class="notification-header">
                    <ion-icon name="notifications-outline" class="jogo-icon"></ion-icon>
                    <span class="jogo-nome">${notif.jogo || 'Jogo'}</span>
                    <span class="unread-badge">Nova</span>
                    <span class="notification-date">${new Date(notif.data).toLocaleDateString('pt-PT')}</span>
                </div>
                <div class="notification-title">${notif.titulo || 'Novo resultado'}</div>
                <div class="notification-subtitle">${notif.subtitulo || ''}</div>
                <div class="notification-resumo">${notif.resumo || 'Ver detalhes'}</div>
            </div>
        `;
    }
    
    listaElement.innerHTML = html;
    
    // Adicionar eventos de clique
    document.querySelectorAll('.notification-card').forEach(card => {
        card.addEventListener('click', async () => {
            const id = card.dataset.id;
            
            // Desativar clique duplo e mostrar indicador
            card.style.pointerEvents = 'none';
            const processing = document.createElement('div');
            processing.className = 'processing';
            processing.innerHTML = '‚è≥ A marcar como lida...';
            card.appendChild(processing);
            
            // Marcar como lida no GitHub
            const resultado = await marcarComoLida(id);
            
            if (resultado) {
                // Remover o card da lista
                card.remove();
                
                // Se n√£o houver mais cards, mostrar mensagem
                if (document.querySelectorAll('.notification-card').length === 0) {
                    listaElement.innerHTML = '<div class="no-notifications">‚ú® Nenhuma notifica√ß√£o</div>';
                }
                
                console.log('‚úÖ Notifica√ß√£o removida da lista');
            } else {
                // Reativar clique se falhou
                card.style.pointerEvents = 'auto';
                processing.remove();
            }
        });
    });
}

// 7. Verificar token ao carregar
function verificarToken() {
    const token = localStorage.getItem("github_token");
    if (!token) {
        const aviso = document.createElement('div');
        aviso.style.cssText = `
            position: fixed;
            bottom: 80px;
            left: 20px;
            right: 20px;
            background: #333;
            color: white;
            padding: 10px;
            border-radius: 8px;
            text-align: center;
            font-size: 14px;
            z-index: 1000;
        `;
        aviso.innerHTML = '‚ö†Ô∏è Token n√£o configurado. <a href="config.html" style="color: #ffd700;">Configurar</a>';
        document.body.appendChild(aviso);
        
        setTimeout(() => aviso.remove(), 5000);
    }
    return token;
}

// 8. Inicializa√ß√£o
document.addEventListener('DOMContentLoaded', async () => {
    console.log('üöÄ Inicializando sistema de notifica√ß√µes');
    
    // Verificar token
    verificarToken();
    
    // Se estiver na p√°gina de notifica√ß√µes
    if (window.location.pathname.includes('notificacoes.html')) {
        await renderizarNotificacoes();
    }
    
    // Sempre atualizar badge
    await atualizarBadge();
    
    // Atualizar badge periodicamente (a cada 30 segundos)
    setInterval(atualizarBadge, 30000);
});

// Adicionar CSS para toast animation
const style = document.createElement('style');
style.textContent = `
    @keyframes fadeInOut {
        0% { opacity: 0; transform: translateY(20px); }
        10% { opacity: 1; transform: translateY(0); }
        90% { opacity: 1; transform: translateY(0); }
        100% { opacity: 0; transform: translateY(-20px); }
    }
`;
document.head.appendChild(style);
